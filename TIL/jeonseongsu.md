
<details>
<summary> 2024.02.28 </summary>

## 오늘 한 것
알고리즘 - 재귀
알고리즘 - 백트래킹
JPA 공부

## 오늘 공부한 것
https://github.com/Algorithm-Niga-mol-ala/Algorithm/tree/main/%EC%A0%84%EC%84%B1%EC%88%98/2%EA%B8%B0/8%EC%A3%BC%EC%B0%A8

### 알고리즘
2468 안전영역<br>
9025 맥주마시면서걸어가기

### JPA
#### flush
> 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영.
1. 변경 감지가 동작해서 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교해서 수정된 엔티티를 찾음. 수정된 엔티티는 수정 쿼리를 만들어 쓰기 지연 SQL 저장소에 등록.
2. 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송

+ flush 호출 시점
  + em.flush()
    + 거의 사용하지 않음
  + 트랜잭션 커밋 시
    + 자동 호출
  + JPQL 쿼리 실행 시
    + 객체지향 쿼리를 호출할 때도 플러시가 실행
    + 영속성 컨텍스트에는 있지만 db에 반영되지 않은 것들이 있을 수 있으므로 자동 호출

## 보완 해야 할 점

+ 다음 주 역량평가 준비
+ 다음 주부터 개발하려면 JPA 빨리 공부하기
</details> 

<details>
<summary> 2024.03.05 </summary>

## 오늘 한 것

와이어프레임 작성<br>
ERD 작성<br>

## 오늘 공부한 것

### Big-O, Big-THeta, Big-Omega에 대해 설명

입력 크기 n 이 무한대로 커질때의 복잡도를 간단히 표현하기 위해 사용하는 표기법.

+ Big-O : 최악의 경우. 점근적 상한. ex) n이 증가함에 따라 f(n) 이 O(n^2)보다 클 수 없음

+ Big-Theta : O 와 Omega 표기가 같은 경우에 사용. ex) 최대 최소 Theta(n^2)의 증가율을 가짐

+ Big-Omega : 최선의 경우, 점근적 하한, ex) n이 증가함에 따라 f(n)이 Omega(n^2) 보다 작을 수 없음

O(1) 의 상수 시간은 입력 크기 n에 대해여 변하지 않고 일정한 시간이 걸림

### 다른 것을 사용하지 않고 Big-O를 사용하는 이유

Big-O는 점근적 상한을 나타내는 표기법으로 해당 알고리즘의 최악의 경우를 나타냄.<br><br>
알고리즘의 평균적인 시간은 의미가 없는 경우가 많음.<br><br>
시간이 평균적으로 이정도 걸린다는 것보다 절대 이 시간 이상은 걸리지 않는다고 말하는 것이 서비스 신뢰도가 높음.<br><br>

### O(1) 은 O(N^2)보다 무조건적으로 빠른가

복잡도를 계산할 때 입력 크기 N이 무한대로 향한다고 생각하기 때문에 상수를 무시.<br> <br>
실제 O(100)인 알고리즘도 O(1)로 표기 되기 때문에 이런 경우 O(N^2)의 알고리즘 보다 n=10 이하의 시간일 때는 느림.<br><br>
</details> 

<details>
<summary> 2024.03.06 </summary>

## 오늘 한 것

API 명세서 작성<br>
빅데이터 전문가 리뷰<br>

## 오늘 공부한 것

### 일반 배열과 링크드 리스트의 비교

> 배열과 링크드 리스트는 데이터를 저장하고 관리하는 데 사용되는 두가지 기본적인 자료구조

+ 배열
  + 연속된 메모리 공간에 데이터를 저장
  + 인덱스를 사용해서 원소에 빠르게 접근이 가능함. O(1)의 시간복잡도
    + 인덱스란 추가적인 쓰기 작업과 저장 공간을 활용해서 검색 속도를 향상시키는 자료구조
    + 인덱스를 활용하면 검색뿐 아니라 수정, 삭제의 성능도 향상되는데 이유는 이 작업들에 항상 검색이 선행되기 때문
    + index를 사용하지 않으면 Full Scan이 일어나서 처리 속도가 떨어짐
      + 장점
      + 테이블 조회 속도 상승으로 인한 성능 향상
      + 전반적인 시스템의 부하를 줄일 수 있음
      + 단점
      + 인덱스를 관리하기 위해 추가적인 저장공간이 필요
      + 검색을 자주하는 테이블에 인덱스를 거는게 좋음
      + 수정, 삭제, 입력이 잦은 테이블에 인덱스를 걸게 되면 인덱스의 크기가 비대해져서 성능이 오히려 저하됨
        + 규모가 큰 테이블
        + 입력이 자주 발생하지 않는 컬럼
        + JOIN이나 WHERE, ORDER BY에 자주 사용되는 컬럼
        + 데이터의 중복도가 낮은 컬럼
    + 인덱스는 해시 테이블이나 B+Tree로 구현함
      + 해시 테이블 기반의 DB 인덱스는 검색에 유리하지만 해시가 = 연산에 특화되었기 때문에 해시 함수의 특성상 값이 1이라도 달라지면 완전히 다른 해시 값을 생성하므로 부등호 연산이 자주 사용되는 데이터 베이스 검색에는 적합하지 않음
      + B+Tree는 리프노드만이 인덱스와 함께 value를 가지고 있고 나머지 노드들은 데이터를 위한 인덱스만을 가지고 있음
      + 리프노드들은 LinkedList로 연결되어 있음
      + 데이터 베이스의 인덱스 컬럼은 부등호를 이용한 순차 검색 연산이 자주 발생될 수 있으므노 BTree의 리프노드들을 LinkedList로 연결해 순차검색을 용이하게 하는 등 Btree를 인덱스에 맞게 최적화.
  + 고정된 크기를 가지고 크기 변경이 어려움. 미리 할당된 메모리 크기를 초과하면 새로운 메모리 공간을 할당하고 데이터를 복사해야함.
  + 원소를 삽입하거나 삭제할 때 원소들을 이동시켜야 해서 시간이 오래 걸릴 수 있음. O(n)의 시간 복잡도.
  + 메모리 사용이 효율적. 각 원소는 인덱스로 접근되고 추가적인 메모리를 사용하지 않음.
+ 링크드 리스트
  + 각 노드가 데이터와 다음 노드에 대한 참조 포인터를 포함
  + 노드들이 연속되지 않은 메모리 공간에 저장됨.
  + 원소에 접근하기 위해서는 리스트를 순차적으로 탐색해야함. O(n)의 시간복잡도.
  + 크기 변경이 쉬움. 새 노드를 동적으로 할당하거나 제거함으로써 리스트의 크기를 변경할 수 있음.
  + 원소를 삽입하거나 삭제할 때 주소만 바꿔주면 되므로 O(1)의 시간복잡도를 가지지만 삭 제 위치를 검색하는에 O(N)의 시간이 듦
  + 배열은 인덱스를 사용한 빠른 접근이 필요하거나 크기가 고정된 경우에 적합.
  + 링크드 리스트는 데이터의 삽입과 삭제가 빈번하거나 크기가 가변적인 경우에 적합.
  
#### 링크드 리스트를 사용해서 구현할 수 있는 다른 자료구조에 대해 설명
   배열로 구현할 수 있는 자료구조는 대부분 만들 수 있다. 대표적으로 스택이나 큐가 있다.
</details> 



<details>
<summary> 2024.03.07 </summary>

## 오늘 한 것

기획 회의<br>


## 오늘 공부한 것
## Indexing
> DataBase 분야에서 Table에 대한 동작 속도를 높여주는 자료구조

### Index의 종류

+ Clusterd Index
  + 자체적으로 물리적인 정렬이 일어남
  + PK를 만들기만해도 정렬이 되어서 검색 성능 향상
  + 중간에 데이터가 들어오면 계속적으로 정렬이 일어남(오버헤드 발생)
+ NonClustered Index
  + 만들어도 정렬이 일어나지 않음
  + 별도의 공간에 인덱스가 저장이 되기 때문에 재정렬이 일어나지 않음
  + 별도에 공간에 있어서 CRUD에는 유리하지만 쓸데없이 full scan을 통해서 봐도 되는  데이터를 index 테이블을 참조하면서 보는 형태로 데이터 조회시에 딜레이가 있을 수 있음
  
### Index의 사용 이유

> 인덱스를 무조건 사용할 필요는 없지만 거의 필수적으로 사용.

+ B-Tree 
  + Root
  + branch
  + leaf
  
+ B+Tree 
  + Root
  + branch
  + leaf
    + leaf 만이 Value를 가지고 있음.
    + 범위 검색에 유리.
    (범위 검색이 불확실하면 db 내부적으로 b-tree로 변환됨)
    
 ## Query Plan
 ### Optimizer
 > 쿼리를 처리할 최적의 경로를 설정해주는 엔진
 
 + 데이터가 많아질수록 튜닝이 중요해짐
 + Plan이라는 이름으로 튜닝을 테스트
 
 + Mysql,MariaDB의 EXPLAIN 키워드
 실제 데이터가 나오는 것이 아닌 이 데이터를 뽑기까지 위한 Optimizer의 플랜에 대한 내용만 반환
 
 >서브쿼리는 데이터의 셀렉트 절(로우 단위) 계속 적으로 로직이 도는데 where절에서 index를 걸어주면 처음 데이터를 뽑기전 한번 계산.
 그래서 서브쿼리가 느림.
 

</details> 

<details>
<summary> 2024.03.08 </summary>

## 오늘 한 것

서류 마무리.


## 오늘 공부한 것

+ 스택 2개로 큐를, 큐 2개로 스택을 만드는 방법과, 그 시간복잡도
  + 스택 2개로 큐(FIFO)
    + stack1, stack2 생성
    + enqueue: stack 1 에 원소를 push, O(1)
    + dequeue: stack 2 가 비어있을 경우, stack 1의 원소를 pop한 뒤 stack2에 push 후 stack2의 top을 pop, O(n)
    + dequeue: stack 2가 차있을 경우 stack2의 top을 pop, O(1) 

  + 큐 2개로 스택을 만드는 방법(LIFO)
    + queue1과 queue2생성
    + push: queue 1이 비어있으면 queue2에 enqueue, 아니면 queue1에 enqueue,O(1)
    + pop: 두 개의 queue 중 비어있지 않은 queue의 원소를 1개만 제외하고 다른 queue로 이동한 뒤 마지막 남은 원소를 반환, O(n)

+ prefix(전위), infix(중위), postfix(후위) 표기법에 대해 설명하고, 이를 스택을 활용해서 계산하는 방법
  + 후위 표기법
    + 컴파일러가 사용하는 것
    + 피연산자를 먼저 표시하고 연산자를 나중에 표시하는 방법
      + 숫자가 나오면 그대로 출력
      + (*/가 나오면 스택에 push
      + +- 연산이 나오면 (, (가 없다면 스택의 끝까지 출력하고 그 연산자를 스택에 push
      + ) 닫는 괄호가 나오면 (가 나올 때까지 pop

+ deque의 구현
  + deque(덱)은 queue의 특성과 stack의 특성을 모두 가지는 자료구조

+ 선형 자료구조
> 연속적으로 자료 뒤에 자료가 배치되는 구조. 배열, 리스트, 스택, 큐
  + 번호(인덱스)와 해당 인덱스에 대응하는 데이터로 이루어진 자료구조
  + 메모리 상에 같은 종류의 데이터들이 순차적으로 저장되고, 인덱스로 해당 자료의 상대적인 위치를 알아낼 수 있다.
  
## 주말에 할 것
1. 대화주제 5개, 대화멘트 5개 만들기
2. 공통 프로젝트 정리, 네이버 지원, 은행 준비
3. 자료구조 다 구현해보기
4. 알고리즘 하루 2개 풀기, sql 1개 
5. 하루 1개 면접 질문 완성


</details> 

<details>
<summary> 2024.03.12 </summary>

## 오늘 한 것

DB 공부

## 오늘 공부한 것
+ 회원 테이블과 비밀번호 테이블의 분리
+ 동시성 고민해보기

## 정규화
> + 목적: 테이블 간에 중복된 데이터를 허용하지 않는 것
+ 데이터의 중복을 허용하지 않음으로써 무결성(Integrity)를 유지할 수 있고,DB의 저장 용량도 줄일 수 있음
+ 데이터 중복은 불필요한 공간을 차지할 뿐 아니라 데이터 베이스 I/O 처리에서 많은 문제를 불러옴
+ 데이터베이스의 성능을 결정 짓는 건 I/O. 데이터 중복은 이런 읽기나 쓰기에 대한 I/O를 증가시킴

+ 제 1 정규화
  + 테이블의 컬럼이 하나의 값만 갖도록 테이블을 분해
  + 컬럼에 여러 값이 들어가지 않고 행을 늘림
+ 제 2 정규화
  + 제 1 정규화를 진행한 테이블에 대해 완전 함수 종속을 만족하도록 테이블을 분해하는 것
    + 완전 함수 종속 : 기본키의 부분집합이 결정자가 되어선 안됨
    + 기본키가 복합키인 경우 복합키 전체가 아닌 부분집합에 종속되어있는 경우가 있음
+ 제 3 정규화
  + 제 2 정규화를 진행한 테이블에 대해 이행적 종속을 없애도록 테이블을 분해하는 것
    + 이행적 종속: X->Y, Y->Z 일 때, X->Z인 상태.
    + X와 Z가 관계없는 값이라 논리적으로 맞지 않는 경우가 있음

#### 유저 테이블 구성하기  

데이터베이스는 인덱스를 사용하던, 풀스캔을 하던 특정 값을 읽어오기 위해서는 그 값이 들어있는 row의 전체 블록에 대한 읽기 작업이 선행됨.

인덱스를 통해 해당 값이 있는 row에 도착해서 row값의 일부분인 해당 값만 읽어오는 것이 아니라 해당 값이 있는 row 전체 블록을 읽어온다.

RDBMS 에서 row는 데이터를 입/출력하는 최소 단위이기 때문에 컬럼이 많으면 많을수록 블록의 읽기가 많아짐.

유저 테이블은 한번 구성을 하게 되면 거의 모든 서비스에서 참조하는 테이블.
따라서 유저 테이블은 컬럼이 많으면 좋지 않음.

스키마를 통해 테이블을 분리하면 SQL 인젝션 공격에 대한 방어가 가능.
스키마를 쉽게 인스턴스로 분리해서 MSA까지 고려하는 구성.

----

## Schema 분리 설계
분산 DB로 구성되는 경우에는 Foreign-Key를 적용할 수 없게 되므로 고민이 필요함.
+ 다른 마이크로 서비스의 데이터를 조회하는 방법. 
+ 데이터 정합성의 보장하는 방법.

1. 어플리케이션 조인
![](https://velog.velcdn.com/images/no-merit/post/92678b03-620f-47fe-851f-efeda9e02b4b/image.png)

+ UserID 별로 월 단위 입,출금 내역 조회
+ UserID 에 대한 세부 정보 요청
+ 세부 정보 Cust 테이블 내 조회
+ 조회 결과 리턴
+ API Composition

+ 논리적으로 조인 작업이 발생하고 있지만 DB가 아닌 어플리케이션 내에서 발생
  + Join을 서비스 내에서 처리하는 것은 굉장히 비효율적인 방식.
+ DB는 Join 처리에 특화된 엔진. 
+ 어플리케이션은 Join처리를 위해 비효율적인 루프를 반복적으로 수행해야 함.
  + 트랜잭션의 전체 대기 시간이 급격하게 증가할 것
  + 특히 대량 쿼리 결과에 따른 Join 처리에서는 차이가 커질 것
  + 실시간 성의 처리가 아니라면 오래 걸려도 상관이 없음
  + 빈번하고 실시간 처리가 필요하면 문제가 됨
    + 대량으로 조회할 때 로컬로 캐싱하면 이런 지연 시간 증가의 영향을 완화 가능
    + CQRS 설계를 적용
    + 비동기 Message Queue 등을 이용해서 공유 테이블에 대해 CQRS DB로 복제하고 이를 독립된 분산DB를 하나의 DB로 모음으로써 join할 수 있도록 제공하느 형태 활용 가능.
---
## 데이터 정합성 보장
> 고객서비스와 이체서비스가 별도의 서비스이고 별도의 스키마를 사용하면 데이터 불일치가 발생할 수 있음.
단일 스키마를 사용하면 이체 테이블에 해당 행에 대한 참조가 있는 경우 고객 테이블의 행을 삭제할 수 없는데 분리된 환경에서는 상호간 정합성을 보장하는 것이 까다로움

+ 삭제 전 확인
  + 고객 테이블에서 레코드를 제거할 때 이체 서비스에 확인해서 레코드에 대한 참조가 없는지 확인 -> 올바르게 동작하는지 보장하기 어려움
    + 확인 작업을 수행하고 응답하는 시간동안 데이터가 변경될 수 있음
    + 행에 대한 lock이 필요한데 lock을 걸면 프로젝트 전체에 문제가 발생 될 수 있음
  + 삭제 전 확인을 하게 되면 역뱡향 종속성이 생긴다는 것
  + 자체 서비스 내 데이터의 변화를 위해 다른 서비스를 확인해야 한다는 것.
  + 소비자가 많을수록 훨씬 더 결합도가 높아지고 확인할 대상도 많아짐.
  + 따라서 작업이 올바르게 구현되었는지 확인하기 어렵고 이로 인해 발생하는 서비스 결합이 높으므로 고려하지 말것.
  
+ 삭제 정상 처리
  + 고객 서비스에 CUSTID에 대한 정보가 없을 수 있다는 사실을 이체 서비스에서 처리
    + 주어진 CUSTID를 조회할 수 없는 경우 월별 이체 정보에 "탈퇴한 사용자입니다." 같은 표시가 되도록 하는 것
  + 고객 서비스는 이전에 존재했던 CUSTID를 요청할 때 알리기
    + 410 GONE HTTP Response 응답 코드 반환
    + 데이터 불일치 문제를 추적할 때 활용하기
  
+ 삭제 불가
  + 고객 서비스의 레코드 삭제를 허용하지 않는 것
  + 상태 열을 사용해서 삭제 기능을 구현함.
 

</details> 



<details>
<summary> 틀 </summary>

## 오늘 한 것


## 오늘 공부한 것


</details> 

