
<details>
<summary> 2024.02.28 </summary>

## 오늘 한 것
알고리즘 - 재귀
알고리즘 - 백트래킹
JPA 공부

## 오늘 공부한 것
https://github.com/Algorithm-Niga-mol-ala/Algorithm/tree/main/%EC%A0%84%EC%84%B1%EC%88%98/2%EA%B8%B0/8%EC%A3%BC%EC%B0%A8

### 알고리즘
2468 안전영역<br>
9025 맥주마시면서걸어가기

### JPA
#### flush
> 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영.
1. 변경 감지가 동작해서 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교해서 수정된 엔티티를 찾음. 수정된 엔티티는 수정 쿼리를 만들어 쓰기 지연 SQL 저장소에 등록.
2. 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송

+ flush 호출 시점
  + em.flush()
    + 거의 사용하지 않음
  + 트랜잭션 커밋 시
    + 자동 호출
  + JPQL 쿼리 실행 시
    + 객체지향 쿼리를 호출할 때도 플러시가 실행
    + 영속성 컨텍스트에는 있지만 db에 반영되지 않은 것들이 있을 수 있으므로 자동 호출

## 보완 해야 할 점

+ 다음 주 역량평가 준비
+ 다음 주부터 개발하려면 JPA 빨리 공부하기
</details> 

<details>
<summary> 2024.03.05 </summary>

## 오늘 한 것

와이어프레임 작성<br>
ERD 작성<br>

## 오늘 공부한 것

### Big-O, Big-THeta, Big-Omega에 대해 설명

입력 크기 n 이 무한대로 커질때의 복잡도를 간단히 표현하기 위해 사용하는 표기법.

+ Big-O : 최악의 경우. 점근적 상한. ex) n이 증가함에 따라 f(n) 이 O(n^2)보다 클 수 없음

+ Big-Theta : O 와 Omega 표기가 같은 경우에 사용. ex) 최대 최소 Theta(n^2)의 증가율을 가짐

+ Big-Omega : 최선의 경우, 점근적 하한, ex) n이 증가함에 따라 f(n)이 Omega(n^2) 보다 작을 수 없음

O(1) 의 상수 시간은 입력 크기 n에 대해여 변하지 않고 일정한 시간이 걸림

### 다른 것을 사용하지 않고 Big-O를 사용하는 이유

Big-O는 점근적 상한을 나타내는 표기법으로 해당 알고리즘의 최악의 경우를 나타냄.<br><br>
알고리즘의 평균적인 시간은 의미가 없는 경우가 많음.<br><br>
시간이 평균적으로 이정도 걸린다는 것보다 절대 이 시간 이상은 걸리지 않는다고 말하는 것이 서비스 신뢰도가 높음.<br><br>

### O(1) 은 O(N^2)보다 무조건적으로 빠른가

복잡도를 계산할 때 입력 크기 N이 무한대로 향한다고 생각하기 때문에 상수를 무시.<br> <br>
실제 O(100)인 알고리즘도 O(1)로 표기 되기 때문에 이런 경우 O(N^2)의 알고리즘 보다 n=10 이하의 시간일 때는 느림.<br><br>
</details> 

<details>
<summary> 2024.03.06 </summary>

## 오늘 한 것

API 명세서 작성<br>
빅데이터 전문가 리뷰<br>

## 오늘 공부한 것

### 일반 배열과 링크드 리스트의 비교

> 배열과 링크드 리스트는 데이터를 저장하고 관리하는 데 사용되는 두가지 기본적인 자료구조

+ 배열
  + 연속된 메모리 공간에 데이터를 저장
  + 인덱스를 사용해서 원소에 빠르게 접근이 가능함. O(1)의 시간복잡도
    + 인덱스란 추가적인 쓰기 작업과 저장 공간을 활용해서 검색 속도를 향상시키는 자료구조
    + 인덱스를 활용하면 검색뿐 아니라 수정, 삭제의 성능도 향상되는데 이유는 이 작업들에 항상 검색이 선행되기 때문
    + index를 사용하지 않으면 Full Scan이 일어나서 처리 속도가 떨어짐
      + 장점
      + 테이블 조회 속도 상승으로 인한 성능 향상
      + 전반적인 시스템의 부하를 줄일 수 있음
      + 단점
      + 인덱스를 관리하기 위해 추가적인 저장공간이 필요
      + 검색을 자주하는 테이블에 인덱스를 거는게 좋음
      + 수정, 삭제, 입력이 잦은 테이블에 인덱스를 걸게 되면 인덱스의 크기가 비대해져서 성능이 오히려 저하됨
        + 규모가 큰 테이블
        + 입력이 자주 발생하지 않는 컬럼
        + JOIN이나 WHERE, ORDER BY에 자주 사용되는 컬럼
        + 데이터의 중복도가 낮은 컬럼
    + 인덱스는 해시 테이블이나 B+Tree로 구현함
      + 해시 테이블 기반의 DB 인덱스는 검색에 유리하지만 해시가 = 연산에 특화되었기 때문에 해시 함수의 특성상 값이 1이라도 달라지면 완전히 다른 해시 값을 생성하므로 부등호 연산이 자주 사용되는 데이터 베이스 검색에는 적합하지 않음
      + B+Tree는 리프노드만이 인덱스와 함께 value를 가지고 있고 나머지 노드들은 데이터를 위한 인덱스만을 가지고 있음
      + 리프노드들은 LinkedList로 연결되어 있음
      + 데이터 베이스의 인덱스 컬럼은 부등호를 이용한 순차 검색 연산이 자주 발생될 수 있으므노 BTree의 리프노드들을 LinkedList로 연결해 순차검색을 용이하게 하는 등 Btree를 인덱스에 맞게 최적화.
  + 고정된 크기를 가지고 크기 변경이 어려움. 미리 할당된 메모리 크기를 초과하면 새로운 메모리 공간을 할당하고 데이터를 복사해야함.
  + 원소를 삽입하거나 삭제할 때 원소들을 이동시켜야 해서 시간이 오래 걸릴 수 있음. O(n)의 시간 복잡도.
  + 메모리 사용이 효율적. 각 원소는 인덱스로 접근되고 추가적인 메모리를 사용하지 않음.
+ 링크드 리스트
  + 각 노드가 데이터와 다음 노드에 대한 참조 포인터를 포함
  + 노드들이 연속되지 않은 메모리 공간에 저장됨.
  + 원소에 접근하기 위해서는 리스트를 순차적으로 탐색해야함. O(n)의 시간복잡도.
  + 크기 변경이 쉬움. 새 노드를 동적으로 할당하거나 제거함으로써 리스트의 크기를 변경할 수 있음.
  + 원소를 삽입하거나 삭제할 때 주소만 바꿔주면 되므로 O(1)의 시간복잡도를 가지지만 삭 제 위치를 검색하는에 O(N)의 시간이 듦
  + 배열은 인덱스를 사용한 빠른 접근이 필요하거나 크기가 고정된 경우에 적합.
  + 링크드 리스트는 데이터의 삽입과 삭제가 빈번하거나 크기가 가변적인 경우에 적합.
  
#### 링크드 리스트를 사용해서 구현할 수 있는 다른 자료구조에 대해 설명
   배열로 구현할 수 있는 자료구조는 대부분 만들 수 있다. 대표적으로 스택이나 큐가 있다.
</details> 



<details>
<summary> 2024.03.07 </summary>

## 오늘 한 것

기획 회의<br>


## 오늘 공부한 것
## Indexing
> DataBase 분야에서 Table에 대한 동작 속도를 높여주는 자료구조

### Index의 종류

+ Clusterd Index
  + 자체적으로 물리적인 정렬이 일어남
  + PK를 만들기만해도 정렬이 되어서 검색 성능 향상
  + 중간에 데이터가 들어오면 계속적으로 정렬이 일어남(오버헤드 발생)
+ NonClustered Index
  + 만들어도 정렬이 일어나지 않음
  + 별도의 공간에 인덱스가 저장이 되기 때문에 재정렬이 일어나지 않음
  + 별도에 공간에 있어서 CRUD에는 유리하지만 쓸데없이 full scan을 통해서 봐도 되는  데이터를 index 테이블을 참조하면서 보는 형태로 데이터 조회시에 딜레이가 있을 수 있음
  
### Index의 사용 이유

> 인덱스를 무조건 사용할 필요는 없지만 거의 필수적으로 사용.

+ B-Tree 
  + Root
  + branch
  + leaf
  
+ B+Tree 
  + Root
  + branch
  + leaf
    + leaf 만이 Value를 가지고 있음.
    + 범위 검색에 유리.
    (범위 검색이 불확실하면 db 내부적으로 b-tree로 변환됨)
    
 ## Query Plan
 ### Optimizer
 > 쿼리를 처리할 최적의 경로를 설정해주는 엔진
 
 + 데이터가 많아질수록 튜닝이 중요해짐
 + Plan이라는 이름으로 튜닝을 테스트
 
 + Mysql,MariaDB의 EXPLAIN 키워드
 실제 데이터가 나오는 것이 아닌 이 데이터를 뽑기까지 위한 Optimizer의 플랜에 대한 내용만 반환
 
 >서브쿼리는 데이터의 셀렉트 절(로우 단위) 계속 적으로 로직이 도는데 where절에서 index를 걸어주면 처음 데이터를 뽑기전 한번 계산.
 그래서 서브쿼리가 느림.
 

</details> 

<details>
<summary> 2024.03.08 </summary>

## 오늘 한 것

서류 마무리.


## 오늘 공부한 것

+ 스택 2개로 큐를, 큐 2개로 스택을 만드는 방법과, 그 시간복잡도
  + 스택 2개로 큐(FIFO)
    + stack1, stack2 생성
    + enqueue: stack 1 에 원소를 push, O(1)
    + dequeue: stack 2 가 비어있을 경우, stack 1의 원소를 pop한 뒤 stack2에 push 후 stack2의 top을 pop, O(n)
    + dequeue: stack 2가 차있을 경우 stack2의 top을 pop, O(1) 

  + 큐 2개로 스택을 만드는 방법(LIFO)
    + queue1과 queue2생성
    + push: queue 1이 비어있으면 queue2에 enqueue, 아니면 queue1에 enqueue,O(1)
    + pop: 두 개의 queue 중 비어있지 않은 queue의 원소를 1개만 제외하고 다른 queue로 이동한 뒤 마지막 남은 원소를 반환, O(n)

+ prefix(전위), infix(중위), postfix(후위) 표기법에 대해 설명하고, 이를 스택을 활용해서 계산하는 방법
  + 후위 표기법
    + 컴파일러가 사용하는 것
    + 피연산자를 먼저 표시하고 연산자를 나중에 표시하는 방법
      + 숫자가 나오면 그대로 출력
      + (*/가 나오면 스택에 push
      + +- 연산이 나오면 (, (가 없다면 스택의 끝까지 출력하고 그 연산자를 스택에 push
      + ) 닫는 괄호가 나오면 (가 나올 때까지 pop

+ deque의 구현
  + deque(덱)은 queue의 특성과 stack의 특성을 모두 가지는 자료구조

+ 선형 자료구조
> 연속적으로 자료 뒤에 자료가 배치되는 구조. 배열, 리스트, 스택, 큐
  + 번호(인덱스)와 해당 인덱스에 대응하는 데이터로 이루어진 자료구조
  + 메모리 상에 같은 종류의 데이터들이 순차적으로 저장되고, 인덱스로 해당 자료의 상대적인 위치를 알아낼 수 있다.
  
## 주말에 할 것
1. 대화주제 5개, 대화멘트 5개 만들기
2. 공통 프로젝트 정리, 네이버 지원, 은행 준비
3. 자료구조 다 구현해보기
4. 알고리즘 하루 2개 풀기, sql 1개 
5. 하루 1개 면접 질문 완성


</details> 


<details>
<summary> 틀 </summary>

## 오늘 한 것


## 오늘 공부한 것


</details> 

