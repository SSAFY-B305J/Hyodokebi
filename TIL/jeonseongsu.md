
<details>
<summary> 2024.02.28 </summary>

## 오늘 한 것
알고리즘 - 재귀
알고리즘 - 백트래킹
JPA 공부

## 오늘 공부한 것
https://github.com/Algorithm-Niga-mol-ala/Algorithm/tree/main/%EC%A0%84%EC%84%B1%EC%88%98/2%EA%B8%B0/8%EC%A3%BC%EC%B0%A8

### 알고리즘
2468 안전영역<br>
9025 맥주마시면서걸어가기

### JPA
#### flush
> 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영.
1. 변경 감지가 동작해서 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교해서 수정된 엔티티를 찾음. 수정된 엔티티는 수정 쿼리를 만들어 쓰기 지연 SQL 저장소에 등록.
2. 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송

+ flush 호출 시점
  + em.flush()
    + 거의 사용하지 않음
  + 트랜잭션 커밋 시
    + 자동 호출
  + JPQL 쿼리 실행 시
    + 객체지향 쿼리를 호출할 때도 플러시가 실행
    + 영속성 컨텍스트에는 있지만 db에 반영되지 않은 것들이 있을 수 있으므로 자동 호출

## 보완 해야 할 점

+ 다음 주 역량평가 준비
+ 다음 주부터 개발하려면 JPA 빨리 공부하기
</details> 

<details>
<summary> 2024.03.05 </summary>

## 오늘 한 것

와이어프레임 작성<br>
ERD 작성<br>

## 오늘 공부한 것

### Big-O, Big-THeta, Big-Omega에 대해 설명

입력 크기 n 이 무한대로 커질때의 복잡도를 간단히 표현하기 위해 사용하는 표기법.

+ Big-O : 최악의 경우. 점근적 상한. ex) n이 증가함에 따라 f(n) 이 O(n^2)보다 클 수 없음

+ Big-Theta : O 와 Omega 표기가 같은 경우에 사용. ex) 최대 최소 Theta(n^2)의 증가율을 가짐

+ Big-Omega : 최선의 경우, 점근적 하한, ex) n이 증가함에 따라 f(n)이 Omega(n^2) 보다 작을 수 없음

O(1) 의 상수 시간은 입력 크기 n에 대해여 변하지 않고 일정한 시간이 걸림

### 다른 것을 사용하지 않고 Big-O를 사용하는 이유

Big-O는 점근적 상한을 나타내는 표기법으로 해당 알고리즘의 최앇의 경우를 나타냄.
알고리즘의 평균적인 시간은 의미가 없는 경우가 많음.
시간이 평균적으로 이정도 걸린다는 것보다 절대 이 시간 이상은 걸리지 않는다고 말하는 것이 서비스 신뢰도가 높음.

### O(1) 은 O(N^2)보다 무조건적으로 빠른가

복잡도를 계산할 때 입력 크기 N이 무한대로 향한다고 생각하기 때문에 상수를 무시하는데 
실제 O(100)인 알고리즘도 O(1)로 표기 되기 때문에 이런 경우 O(N^2)의 알고리즘 보다 n=10 이하의 시간일 때는 느림.
</details> 


<details>
<summary> 틀 </summary>

## 오늘 한 것


## 오늘 공부한 것


</details> 

